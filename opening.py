import time
import threading


""" Пишу функцию,которую буду запускать через поток. currentThread() - получение текущего потока.
 Так как эта ф-я работает в текущем потоке, то мы можем исп-ть методы данного потока и атрибуты"""


def get_data(data):
    while True:
        print(f'[{threading.currentThread().name}] - {data}')
        time.sleep(1)

""" Использую поток, где target - адрес на объект (функцию), name - название потока,
args=() - аргументы ф-ии (можно через kwargs), daemon или обычный поток.
Метод start() можно использовать в нижней строке, но тогда объект создавать нельзя, либо
как строка еще ниже"""

thr = threading.Thread(target=get_data, args=(str(time.time()),), name='thr-1')

""" Метод start() - запуск потока"""

thr.start()

""" Для того, чтобы проверить что get_data() выполняется в отдельном потоке запущу ф-ю,
которая выполняется в текущем потоке и яв-ся блокирующей. Если бы ф-я не выполняется в потоке,
то последующий код не даст ей работать (последовательность потоков). Если же ф-я работает в фоне,
то будет выполняться и она и последующий код """

for i in range(100):
    print(f'current : {i}')
    time.sleep(1)

    """ В итоге работает и основной поток программы (цикл) и поток,
    который мы запустили (thr-1). Программа работает в основном потоке (по умолчаниию)
    , то есть она выделяет поток для работы основного кода, а остальные потоки 
    создаются вручную. Также при выводе значений они могут выводиться не в том порядке 
    (синхронизация потоков) """

    """ Проверка, работает ли поток до сих пор, вывод списка активных потоков, вывод всех
    запущенных потоков """

    if i % 10 == 0:
        print('active thread:', threading.active_count()) # кол-во активных потоков
        print('enumerate:', threading.enumerate()) # кол-во потоков, запущенных в данный момент
        print('thr-1 is alive:', thr.is_alive()) # проверка, работает ли запущенный в данный момент поток

""" Метод join позволяет дождаться выполнения моего потока"""
